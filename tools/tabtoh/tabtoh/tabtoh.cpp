/*
    Copyright (C) 2019 Lubomir Bogdanov

    Contributor Lubomir Bogdanov <lbogdanov@tu-sofia.bg>

    This file is part of Powot Simulator.

    Powot Simulator is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Powot Simulator is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Powot Simulator.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "tabtoh.h"

bool tabtoh::read_entire_file(const QString &filename, QStringList &contents){
    bool err = 0;
    QString currentline;

    QFile file(filename);
    err = file.open(QIODevice::ReadOnly|QIODevice::Text);
    if(err){
        err = 1;
        QTextStream FileStream(&file);
        while(!FileStream.atEnd()){
            currentline = FileStream.readLine();
            //Exclude comments
            if(currentline.contains("#")){
                int ind = currentline.indexOf("#");
                ind = currentline.size() - ind;
                currentline.chop(ind);
            }

            //Replace zero-length line with a newline
            if(currentline.size()){
                contents << currentline;
            }
            else{
                contents << "\r\n";
            }
        }
        file.close();
    }
    else{
        qDebug()<<"(tabtoh) ERROR: cannot open: "<<filename<<"!";
    }

    return err;
}

bool tabtoh::write_entire_file(QString &filename, QStringList &contents){
    bool err = 0;

    QFile file(filename);
    err = file.open(QIODevice::WriteOnly | QIODevice::Text);
    if(err){
        err = 1;
        QTextStream FileStream(&file);
        for(qint32 i = 0; i < contents.size(); i++){
            FileStream << contents.at(i);
        }

        file.close();
    }
    else{
       qDebug()<<"(tabtoh) ERROR: cannot write to: "<<filename<<"!";
    }

    return err;
}

tabtoh::tabtoh(){

}

tabtoh::tabtoh(QString &in_file_str, QString &out_file_str, QString &mod_name_str){
    qDebug()<<"(tabtoh) Input: "<<in_file_str;
    qDebug()<<"(tabtoh) Output: "<<out_file_str;
    qDebug()<<"(tabtoh) Model: "<<mod_name_str;

    input_file_str = in_file_str;
    output_file_str = out_file_str;
    model_name_str = mod_name_str;

    read_entire_file(input_file_str, input_file);
}

tabtoh::~tabtoh(){

}

int tabtoh::convert(){
    bool err = 1;
    QString instr_mnemonic;
    QString num_of_instr_str;
    QString temp_line;
    QStringList instr_description;
    QStringList converted_instr_description;
    QStringList instr_names_list;
    int num_of_instr = 0;
    int instr_num_of_lines = 0;

    qDebug()<<"(tabtoh) Counting instructions ...";
    num_of_instr = count_instructions();
    num_of_instr_str = QString::number(num_of_instr, 10);
    qDebug()<<"(tabtoh) Instructions: "<<num_of_instr;

    qDebug()<<"(tabtoh) Extracting instructions ...";
    for(int i = 0; i < input_file.size(); i++){
        if(input_file.at(i).contains("INSTR")){
            instr_mnemonic = input_file.at(i).section('\t', 1, 1);
            instr_mnemonic.prepend("&");
            instr_names_list << instr_mnemonic;

            for(int j = i; j < input_file.size(); j++){
                instr_description << input_file.at(j);
                instr_description << "\r\n";
                instr_num_of_lines++;
                if(is_empty_line(input_file.at(j))){
                    break;
                }
            }

            if(instr_num_of_lines){
                converted_instr_description << parse_and_convert_instr(instr_description);
                instr_num_of_lines = 0;
                instr_description.clear();
            }
        }
    }


    insert_comment("/* Automatically generated by tabtoh */", output_file);
    insert_newline(output_file);
    insert_ifndef("ISA_H_", output_file);
    insert_include("common.h", output_file);
    insert_newline(output_file);
    insert_define("NUM_OF_INSTRUCTIONS", num_of_instr_str.toLatin1().data(), output_file);
    insert_newline(output_file);
    output_file += converted_instr_description;
    insert_newline(output_file);
    insert_array("const instruction_t*", model_name_str.toLatin1().data(), "NUM_OF_INSTRUCTIONS", instr_names_list, output_file);
    insert_endif(output_file);

    write_entire_file(output_file_str, output_file);

    return err;
}

int tabtoh::count_instructions(){
    int num_of_instr = 0;

    for(int i = 0; i < input_file.size(); i++){
        if(input_file.at(i).contains("INSTR")){
            num_of_instr++;
        }
    }

    return num_of_instr;
}

void tabtoh::insert_comment(const char *comment_str, QStringList &string_list){
    string_list << comment_str;
}

void tabtoh::insert_ifndef(const char *ifndef_str, QStringList &string_list){
    QString temp;
    temp = "#ifndef ";
    temp += ifndef_str;
    temp += "\r\n";
    string_list << temp;

    temp = "#define ";
    temp += ifndef_str;
    temp += "\r\n";
    string_list << temp;

    temp = "\r\n";
    string_list << temp;
}

void tabtoh::insert_endif(QStringList &string_list){
    string_list << "#endif\r\n";
}

void tabtoh::insert_include(const char *include_str, QStringList &string_list){
    QString temp;
    temp = "#include \"";
    temp += include_str;
    temp += "\"\r\n";
    string_list << temp;
}

void tabtoh::insert_define(const char *define_name, const char *define_value, QStringList &string_list){
    QString temp;
    temp = "#define ";
    temp += define_name;
    temp += " ";
    temp += define_value;
    temp += "\r\n";
    string_list << temp;
}

void tabtoh::insert_newline(QStringList &string_list){
    string_list << "\n";
}

bool tabtoh::is_empty_line(const QString &line){
    bool result = 0;

    if(line.isEmpty()){
        result = 1;
    }
    else if(line.contains("\n") && (line.size() == 1)){
        result = 1;
    }
    else if(line.contains("\r") && (line.size() == 1)){
        result = 1;
    }
    else if(line.contains("\n\r") && (line.size() == 2)){
        result = 1;
    }
    else if(line.contains("\r\n") && (line.size() == 2)){
        result = 1;
    }

    return result;
}

void tabtoh::insert_array(const char *arr_type, const char *arr_name, const char *arr_size, QStringList &arr_elements, QStringList &string_list){
    QString member_temp;
    QString temp;

    temp = arr_type;
    temp += " ";
    temp += arr_name;
    temp += "[";
    temp += arr_size;
    temp += "] = {";
    string_list << temp;
    string_list << "\r\n";

    for(int i = 0; i < arr_elements.size(); i++){
        member_temp += arr_elements.at(i);
        member_temp += ", ";
        if(((i % 8) == 0) && (i != 0)){
            member_temp += "\r\n";
            string_list << member_temp;
            member_temp.clear();
        }
    }

    if(!member_temp.isEmpty()){
        member_temp += "\r\n";
        string_list << member_temp;
    }

    temp = "};";
    string_list << temp;
    string_list << "\r\n";
}

QStringList tabtoh::parse_and_convert_instr(QStringList &instr_desc){
    QStringList converted_instr;

    converted_instr = instr_desc;

    return converted_instr;
}

/*
            for(int j = i; j < input_file.size(); j++){
                if(input_file.at(j).contains("ADDR")){
                    err = 0;
                    num_of_mem_domains++;
                }
                if(input_file.at(j).contains("ADDR")){
                    err = 0;
                    num_of_mem_domains++;
                }
                else if(input_file.at(j).contains("TEMPERATURES")){
                    err = 0;
                    num_of_tempr_domains++;
                }
                else if(input_file.at(j).contains("VOLTAGES")){
                    err = 0;
                    num_of_volt_domains = input_file.at(j).count('\t');
                }
                else if(input_file.at(j).contains("FREQUENCIES")){
                    err = 0;
                    num_of_freq_domains = input_file.at(j).count('\t');
                }
                else if(input_file.at(j).contains("OPERANDS")){
                    err = 0;
                    num_of_operand_domains = input_file.at(j).count('\t');
                }
*/
